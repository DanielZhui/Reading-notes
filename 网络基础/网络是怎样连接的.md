# 网络是怎样连接的

## 浏览器生成的消息 —— 探索浏览器内部

### 生产 HTTP 请求消息

### 向 DNS 服务器查询 Web 服务器的 IP 地址

#### IP 地址的基础知识

​    生成 HTTP 消息之后，接下来我们需要委托操作系统将消息发送给 Web 服务器【浏览器能够解析网址并生成 HTTP 消息，但它本身不具备发到网络的功能】，在进行这一操作时，我们还有一个工作需要完成，就是查询网址中服务器域名对应的 IP 地址。在委托操作系统发送消息时，必须要提供请求服务器的 IP 地址。因此下一个步骤是根据域名查询 IP 地址。

​	互联网和公司内部的局域网都是基于 TCP/IP 的思路来设计的，所以我们需要先了解 TCP/IP 的基本思路，如下图所示。

​	在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的 xx号xx室。其中 号 对应的号码是分配给整个子网的，而 室 对应的号码是分配给子网中的计算机的，这就是网络中的地址。号 对应的号码称为网络号，室 对应的号码称为主机号，这个地址整体称为 IP 地址。通过 IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。

![image-20220308220121337](http://static.wollens.top/image-20220308220121337.png)

实际 IP 地址是一串 32 比特的数字，按照 8 比特（1个字节）为一组分成四组，分别用十进制表示然后再用圆点隔开。这就是我们平时常见的 IP 地址格式，但是仅凭一串数字我们无法区分那部分是网络号，那部分是主机号。在 IP 地址的规则中，网络号和主机号连起来共识 32 比特，蛋这两部分的具体结构是不固定的。在组建网络是，用户可以自行决定它们之间的分配关系，因此我们还需要另外的附加信息来表示 IP 地址的内部结构

<img src="http://static.wollens.top/image-20220308221224656.png" alt="image-20220308221224656" style="zoom:50%;" />

子网掩码的格式如下图所示，是一串与 IP 地址长度相同的 32 比特数字，其左边一半都是1，右边一半都是0。其中子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。

<img src="http://static.wollens.top/image-20220308222308302.png" alt="image-20220308222308302" style="zoom:50%;" />

> 备注：主机号部分的比特全部为 0 或者全部为 1 时代表两种特许的含义。主机号部分全部为 0 代表整个子网而不是子网中的某台设备。主机号全部为1代表向子网上所有的设备发送包，即广播



#### 域名和IP地址并用的理由

​	TCP/IP 网络是通过 IP 地址来确定通信的对象，因此不知道 IP 地址就无法将消息发送给对方，因此，在委托操作系统发送消息是，必须要先查询号对方的 IP 地址。

​	既然需要通过域名来查找服务器 IP，那为啥不直接使用 IP 地址访问？实际上，如果用 IP 地址代替服务器名称也是能够正常工作的。然而记一串 IP 地址比较困难，因此相比 IP 地址，网址中使用域名形式访问还是会比较好。

​	现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，这样就能够在任何机器双方都不做出牺牲的前提下完美解决问题，这个机制就是 DNS



#### Socket 库提供查询 IP 地址的功能

​	通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫做解析器。解析器实际上是一段程序，他饱含在操作系统的 Socket 库中，在介绍解析器之前，我们先来简单了解一下 socket 库。首先，库到底是什么东西？库就是一对通用程序组件的集合，其他的应用程序都需要使用其中的组件。库有很多好处。首先，使用线程的组件搭建应用程序可以节省编程工作量；其次，多个程序使用相同的组件可以实现程序的标准化。Socket 库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是合格库中的其中一种程序组件。



#### 通过解析器向 DNS 服务器发出查询

​	解析器的用法非常简单。Socket 库中的程序都是标准组件，只要从应用程序中进行调用就可以。具体来说，在编写浏览器等应用程序的时候，只要想下图所示协商解析器程序名称 "gethostbyname" 以及 Web 服务器的域名 "www.lab.glasscom" 就可以，这样就完成了对解析器的调用。

<img src="http://static.wollens.top/image-20220309153129375.png" alt="image-20220309153129375" style="zoom:50%;" />

​	在应用程序中编写上图中的一行代码后就能够调用解析器完成向 DNS 服务器查询 IP 地址的操作。

​	调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回相应消息。响应消息中包含查询到的 IP 地址，解析器会取出 IP 地址，并将其写入浏览器指定的内存地址中，只要运行上图中这一行程序，就可以完成前面所有这些工作，我们也就完成了 IP 地址的查询。接下来，浏览器在向 Web 服务器发送消息时，你要从该内存中取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以。



#### 解析器的内部原理

​	下面来看一看应用程序调用解析器时，解析器内部是如何工作的。解析器内部工作原理如下：

<img src="http://static.wollens.top/image-20220309154012630.png" alt="image-20220309154012630" style="zoom:67%;" />

​	一般来说，应用程序编写的操作内容是从上往下按顺序执行的，当到达需要调用解析器的部分时，对应的那一行程序就会被执行，应用程序本身的工作就会暂停（图1.12①）。然后，Socket库中的解析器开始运行（图1.12②），完成应用程序委托的操作。像这样，由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行，这就是“控制流程转移”[插图]。当控制流程转移到解析器后，解析器会生成要发送给DNS服务器的查询消息。这个过程与浏览器生成要发送给Web服务器的HTTP请求消息的过程类似，解析器会根据DNS的规格，生成一条表示“请告诉我www.lab.glasscom.com的IP地址”[插图]的数据，并将它发送给DNS服务器（图1.12③）。发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈[插图]来执行。这是因为和浏览器一样，解析器本身也不具备使用网络收发数据的功能。解析器调用协议栈后，控制流程会再次转移，协议栈会执行发送消息的操作，然后通过网卡将消息发送给DNS服务器（图1.12④⑤）。

​	当DNS服务器收到查询消息后，它会根据消息中的查询内容进行查询。这个查询的过程有点复杂，我们稍后会进行讲解，这里先不关心具体的方法。总之，如果要访问的Web服务器已经在DNS服务器上注册，那么这条记录就能够被找到，然后其IP地址会被写入响应消息并返回给客户端（图1.12⑥）。接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器（图1.12⑦⑧），然后解析器读取出消息取出IP地址，并将IP地址传递给应用程序（图1.12⑨）。实际上，解析器会将取出的IP地址写入应用程序指定的内存地址中，图1.11用“<内存地址>”来表示，在实际的程序代码中应该写的是代表这一内存地址的名称。

​	到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器）。现在应用程序已经能够从内存中取出 IP 地址了，所以说 IP 地址是用这种方式传递给应用程序的。

​	计算机中的内部结构是一层一层的，也就是说，很多程序组成不同的层次，彼此之间分工协作，当接到上层委派的操作时，本层的程序并不完成所有的工作，而是会完成一部分工作，再将剩下的部分委派到下层来完成。

​	顺带一提，向 DNS 服务器发送消息时，我嗯当然也需要知道 DNS 服务器的 IP 地址，只不过这个 IP 地址是作为 TCP/IP 的一个设置项目实现设置好的，不需要再去查询。不同操作系统中 TCP/IP 的设置方法也有差异，Windows 中的设置如图所示，解析器会根据这里设置的 DNS 服务器 IP 地址来发送消息

<img src="http://static.wollens.top/image-20220309155212245.png" alt="image-20220309155212245" style="zoom:50%;" />

### 全世界 DNS 服务器大接力

#### DNS 服务器的基本工作

​	前面介绍了解析器与 DNS 服务器之间的交互过程，下面了解一下 DNS 服务器的工作。DNS 服务器的基本工作就是接受来自客户端的查询消息，然后根据消息的内容返回相应

​	其中，来自客户端的查询消息包含一下3中信息

 1. 域名

    服务器、邮件服务器（邮件地址中@后面的部分）的名称

 2. Class

    在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而 Class 就是用来标识网络的信息，不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN

 3. 记录类型

    表示域名对应何种类型的记录，例如：当类型为 A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同

​	DNS 服务器上事先保存有前面这 3 种信息对应的记录数据，如下图所示。DNS 服务器就是根据和谐记录查找符合查询请求的内容并对客户端作出相应的

<img src="http://static.wollens.top/image-20220309160117576.png" alt="image-20220309160117576" style="zoom:67%;" />

总结：DNS 服务器的基本工作原理就是根据需要查询的域名和记录类型查找相关的记录，并向客户端返回响应消息。

​	前面只介绍 A 和 MX 这两个记录类型，实际上还有很多其他的类型。例如根据 IP 地址反查域名和 PTR 类型，查询域名相关别名的 CNAME 类型，查询 DNS 服务器 IP 地址的 NS 类型，以及查询域名属性信息的 SOA 类型等。尽管 DNS 服务器的工作原理很简单，不过是根据查询消息中的域名和记录类型来进行查找并返回响应信息而已，但通过组合使用不同的记录类型，就可以处理各种各样的信息。此外，虽然图中展示的是表格形式，但实际上这些信息是保存在配置文件中的，表格中的一行信息被称为一条资源记录。



#### 域名的层次结构

​	互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台服务器中是不可能的，因此一定会出现 DNS 服务器找不到要查询的信息的情况。下面来看一看此时 DNS 服务器是如何工作的。

​	直接说出答案其实很简单，就是将信息分布保存在多台 DNS 服务器中，这些 DNS 服务器相互接力配合，从而查出要查询的信息。不过这个机制其实有点复杂，因此我们先来看一看信息是如何在 DNS 服务器上注册保存的。

​	首先，DNS 服务器中的所有信息都是按照区域以分层的结构来保存的。层次结构这个词听起来可能有点不容易懂，其实就是类似公司中的事业集团、部门、科室这样的结构。层次结构能够帮组我们更好的管理大量的信息。

​	DNS中的域名都是用句点来分隔的，比如www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已[插图]。在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。其中，相当于一个层级的部分称为域。因此，com域的下一层是glasscom域，再下一层是lab域，再下面才是www这个名字。

​	DNS中的域名都是用句点来分隔的，比如www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已[插图]。在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。其中，相当于一个层级的部分称为域。因此，com域的下一层是glasscom域，再下一层是lab域，再下面才是www这个名字。



#### 寻找响应的 DNS 服务器并获取 IP 地址

​	下面再来看一看如何找到 DNS 服务器中存放的信息，这里的关键在于如何找到我们要访问的Web服务器的信息跪哪一台DNS服务器管。

​	互联网中有数万台DNS服务器，肯定不能一台一台挨个去找。我们可以采用下面的办法。首先，将负责管理下级域的DNS服务器的IP地址注册到它们的上级DNS服务器中，然后上级DNS服务器的IP地址再注册到更上一级的DNS服务器中，以此类推。也就是说，负责管理lab.glasscom.com这个域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，而glasscom.com域的DNS服务器的IP地址又需要注册到com域的DNS服务器中。这样，我们就可以通过上级DNS服务器查询出下级DNS服务器的IP地址，也就可以向下级DNS服务器发送查询请求了。

​	在前面的讲解中，似乎com、jp这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS服务器的信息，但实际上并非如此。在互联网中，com和jp的上面还有一级域，称为根域。根域不像com、jp那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像www.lab.glasscom.com．这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的DNS服务器中保管着com、jp等的DNS服务器的信息。由于上级DNS服务器保管着所有下级DNS服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的DNS服务器。

​	除此之外还需要完成另一项工作，那就是将根域的DNS服务器信息保存在互联网中所有的DNS服务器中。这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器了。因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器（图1.15）。分配给根域DNS服务器的IP地址在全世界仅有13个[插图]，而且这些地址几乎不发生变化，因此将这些地址保存在所有的DNS服务器中也并不是一件难事。实际上，根域DNS服务器的相关信息已经包含在DNS服务器程序的配置文件中了，因此只要安装了DNS服务器程序，这些信息也就被自动配置好了。

​	到这里所有的准备工作都完成了，当我们配置一台 DNS 服务器时，必须要配置好上面这些信息，这样 DNS 服务器就能够从上万台 DNS 服务器中找到目标服务器。下图展示这个过程是如何进行的

<img src="http://static.wollens.top/image-20220309170832901.png" alt="image-20220309170832901" style="zoom:50%;" />

​	如下图所示：客户端首先会访问最近的一台DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址），假设我们要查询www.lab.glasscom.com这台Web服务器的相关信息（图1.16①）。由于最近的DNS服务器中没有存放www.lab.glasscom.com这一域名对应的信息，所以我们需要从顶层开始向下查找。最近的DNS服务器中保存了根域DNS服务器的信息，因此它会将来自客户端的查询消息转发给根域DNS服务器（图1.16②）。根域服务器中也没有www.lab.glasscom.com这个域名，但根据域名结构可以判断这个域名属于com域，因此根域DNS服务器会返回它所管理的com域中的DNS服务器的IP地址，意思是“虽然我不知道你要查的那个域名的地址，但你可以去com域问问看”。接下来，最近的DNS服务器又会向com域的DNS服务器发送查询消息（图1.16③）。com域中也没有www.lab.glasscom.com这个域名的信息，和刚才一样，com域服务器会返回它下面的glasscom.com域的DNS服务器的IP地址。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器（图1.16⑤），只要向目标DNS服务器发送查询消息，就能够得到我们需要的答案，也就是www.lab.glasscom.com的IP地址了。

![image-20220309171052934](http://static.wollens.top/image-20220309171052934.png)

​	收到客户端的查询消息之后，DNS服务器会按照前面的方法来查询IP地址，并返回给客户端（图1.16⑥）。这样，客户端就知道了Web服务器的IP地址，也就能够对其进行访问了（图1.16⑦）



#### 通过缓存加快 DNS 服务器的响应

​	图1.16展示的是基本原理，与真实互联网中的工作方式还是有一些区别的。在真实的互联网中，一台DNS服务器可以管理多个域的信息，因此并不是像图1.16这样每个域都有一台自己的DNS服务器。图中，每一个域旁边都写着一台DNS服务器，但现实中上级域和下级域有可能共享同一台DNS服务器。在这种情况下，访问上级DNS服务器时就可以向下跳过一级DNS服务器，直接返回再下一级DNS服务器的相关信息。

​	此外，有时候并不需要从最上级的根域开始查找，因为DNS服务器有一个缓存[插图]功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。

​	这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。因此，DNS服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。而且，在对查询进行响应时，DNS服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的DNS服务器。



### 委托协议栈发送消息

#### 数据首发操作概览

​	知道 IP 地址后，就可以委托操作系统内部的协议栈向这个目标 IP 地址（web 服务器）发送消息。要发送给 web服务器的 HTTP 消息是一种数字信息，因此也可以说是委托协议栈发送数字信息。

​	和向 DNS 服务器查询 IP 地址的操作一样，这里也需要使用 Socket 库中的程序组件，不过这里需要按照顺序调用多个程序组件，这个过程有点复杂，我们先介绍一下收发数据操作的整体思路

​	使用 Socket 库来收发数据的操作如下图所示，简单来说，收发数据的两台计算机之间连接了一条双向数据通道，数据沿着这条通道流动，最终到达目的地。

<img src="http://static.wollens.top/image-20220309232012721.png" alt="image-20220309232012721" style="zoom:67%;" />

​	收发数据的整体思路是这样的，但还有一点也非常重要。光从图上来看，这条管道好像一开始就有，但实际上并不是这样，在进行收发数据操作之前，双发需要先建立这条管道。建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将台接字连接起来形成管道。实际过程是下面这样的。首先，服务器一方会先创建套接字，然后等待客户端向该套接字连接管道。当服务器进入等待状态时，客户端就可以连接管道。具体来说，客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务端的套接字上。当双方的套接字连接起来之后，通信准备就完成了。接下来，只要将数据送入套接字就可以收发数据了。

​	我们再来看一看收发数据操作结束时的情景。当数据全部发送完毕之后，连接的管道将会被断开。管道在连接时又客户端发起，但在断开时可以有客户端或服务端任意一方发起，其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。到此为止，通信操作就结束了。ß

​	综上所述，收到数据的操作可以大致分为一下4个：

	1. 创建套接字（创建套接字阶段）
	1. 将管道连接到服务端的套接字上（连接阶段）
	1. 收发数据（通信阶段）
	1. 断开管道并删除套接字（断开阶段）

​	在每个阶段，Socket 库中的程序组件都会被调用来执行相关的数据收发操作。前面这4个操作都是有操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、收入数据这些工作，而是委托协议栈代劳。



#### 创建套接字阶段

​	下面我们来探索一下应用程序（浏览器）委托收发数据的过程。

​	首先是套接字创建阶段。客户端创建套接字非常简单，只要调用 Socket 库中的 socket 程序组件就可以。和调用解析器一样，调用 socket 之后，控制流程会转移到 socket 内部执行创建套接字的操作，完成之后流程又会被移交回应用程序。只不过，socket 的内部操作并不像解析器那样简单，后面会有详细讲解，现在大家只要知道调用 socket 后套接字就创建好就可以。

​	套接字创建完成后，协议栈回返回一个描叙符，应用程序会将收到的描叙符存放在内存中。描述符是用来识别不同的套接字。因为同一台机器可能同时访问多个网页，可能同时存在多个套接字，在这种情况下，我们需要识别出某个特定的套接字，这种方法就是描述符。我们可以将描述符理解成给某个套接字分配的编号。当创建套接字后我们就可以使用这个套接字来执行收发数据的操作。这是我们出示描述符，协议栈就能够判断出我们希望用那一个套接字来连接或者收发数据。

![image-20220310151229430](http://static.wollens.top/image-20220310151229430.png)

内部分为：创建套接字、连接 Web 服务器、发送数据、接受数据、断开连接几个阶段ß



> 备注：书中出现的 Socket、socket、套接字看起来很容易混淆，其中小写的 socket 表示程序组件的名称，大写字母开头的 Socket 表示库，而汉字 套接字 则表示管道两端的借口



#### 连接阶段：把管道连接上去

​	接下来，我们需呀委托协议栈将客户端创建的套接字于服务器那边的套接字连接起来。应用程序通过调用 Socket 库中 connect 组件来完成这一操作。这里的要点是当调用 connect 时，需要指定描叙符、服务器 IP 地址和端口号这3个参数。

​	第一个参数：描述符，就是在创建套接字的时候由协议栈返回的那个描述符。connect 会讲应用程序追定的描述符告知协议栈，然后协议栈根据这个描叙符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接操作。

​	第二个参数：即服务器 IP 地址，就是通过 DNS 服务器查询得到的我们要访问的服务器 IP 地址。

​	第三个参数：即端口号，IP 地址是为区分网络中的各个计算机而分配的数值，因此只知道 IP 地址，我们就可以识别出网络上的某台计算机。但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址是无法做到这一点的。当同时指定 IP 和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。描述符是和委托创建套接字的应用程序交互时使用的，并不是用来告诉网络连接的另一方，因此另一方并不知道这个描述符。所以我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。如果说描叙符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。

​	既然需要通过端口号来确定连接对象的套接字，但是网址中好像并没有端口号，也不能像 IP 地址一样去问 DNS 服务器。其实服务器上使用的端口号是根据应用的种类事先规定好的。比如：Web 默认是 80 端口，电子邮件默认是 25 号端口。关于端口号后面还会继续介绍。

​	大家可能有个疑问，既然确定连接对象的套接字需要使用端口号，那么服务器套接字也得得知客户端的端口号才行吧，这个问题是如何解决的，事情是这样的，首先客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随机分配的端口号通知给服务器，这部分内容我们后面会在第2章探索协议栈内部工作时进行介绍

​	总结：当调用 Socket 中 connect 组件时，协议栈会执行连接操作。当连接成功后，协议栈后会将对方的 IP 地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。



#### 通信阶段：传递消息

​	当套接字连接之后，只要将数据送入套接字，数据就会被发送到对方的套接字中，这个过程还是要通过 Socket 库委托协议栈来完成这个操作。这个操作需要使用 write 这个程序组件，具体过程如下：

​	首先，应用程序需要在内存中准备好要发送的数据。根据用户输入的网址生成的HTTP请求消息就是我们要发送的数据。接下来，当调用write时，需要指定描述符和发送数据（图1.18③），然后协议栈就会将数据发送到服务器。由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。接着，发送数据会通过网络到达我们要访问的服务器。接下来，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息。

​	当消息返回后，需要执行的是接收消息的操作。接收消息的操作是通过Socket库中的read程序组件委托协议栈来完成的（图1.18③'）。调用read时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。于是，当服务器返回响应消息时，read就会负责将接收到的响应消息存放到接收缓冲区中。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。



#### 断开阶段：收发数据结束

​	当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket库的close程序组件进入断开阶段（图1.18④）。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。

​	断开的过程如下。Web使用的HTTP协议规定，当Web服务器发送完响应消息之后，应该主动执行断开操作[插图]，因此Web服务器会首先调用close来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用read执行接收数据操作时，read会告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用close进入断开阶段。

​	这就是HTTP的工作过程。HTTP协议将HTML文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在HTTP版本1.1中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。



## 用电信号传输 TCP/IP —— 探索协议栈网卡

![image-20220310190756903](http://static.wollens.top/image-20220310190756903.png)

1. 创建套接字

   从应用程序收到委托后，协议栈通过 TCP 协议收发数据的操作可以分为4个阶段，首先是创建套接字，在这个阶段我们将介绍协议栈内部结构、套接字的实体，以及创建套接字的操作过程。到这里大家应该可以对套接字到底是什么样一个东西有一个比较具体的理解。

2. 连接服务器

   接下来是客户端套接字向服务器套接字进行连接的阶段，我们将介绍 连接 具体是进行怎样的操作，在这个过程中协议栈到底是如何工作的，以及客户端和服务器是如何进行交互的。

3. 收发数据

   两端的套接字完成连接之后，就进入收发消息阶段。在这个阶段协议栈会将应用程序收到的数据切成小块并发送给服务器，考虑到通信过程可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送到服务器，对于没有送达的包要重新发送一次。这里我们将对收发数据的情形加以说明

4. 从服务器断开连接并删除套接字

   收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。断开操作的本质是当消息收发完成后客户端和服务器互相确认的过程，但这个过程并不只是相互确认并删除套接字那么简单，其中有些地方是很有意思的。

5. IP 与以太网的包收发操作

   在介绍 TCP 协议收发消息的操作之后，我们再来看看实际网络包是如何进行收发的。协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。介绍完这个过程后，大家应该可以对计算机网络功能有一个完整的概念了。

6. 用 UDP 协议收发数据的操作

   TCP 协议有很多方便的功能，比如网络出错丢失时可以重发，因此很多应用程序都是使用 TCP 协议来收发数据的，单这些方便的功能也有帮倒忙的时候，在这种情况喜爱我们还有另外一种叫 UDP 的协议。这里我们将介绍 UDP 的必要性以及它与 TCP 的差异。

### 创建套接字

#### 协议栈内部结构

​	本章将探索操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何将浏览器的消息发送给服务器的。和浏览器不同的是，协议栈的工作我们从表面是看不见的。因此在实际探索前，我们先来对协议栈做解析，看看里面到底有些什么。

​	协议栈的内部如图2.1所示，分为几个部分，分别承担不同的功能。下图中的上下关系是有一点规则的。上面的部分会向下面的部分委派工作，下面的部分接受委派工作并实际执行。但这知识一个总体规则，其他也有一部分上下关系不明确，或者上下关系相反的情况。对于图中的每个部分以及他们的工作方式，本章将按顺序进行介绍。

![image-20220311115422438](http://static.wollens.top/image-20220311115422438.png)

​	上层会向下层组层委派工作。图中最上面的部分是网络应用程序，也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分完成。当然除了浏览器之外，其他应用程序在网络上收发数据的操作也都类似上面这样的，也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。因此下面介绍的内容不仅适用于浏览器同时也适用于各种应用程序。

​	应用程序下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询。

​	在下面就是操作系统内部，其中包括协议栈。协议栈的上半部分有两块，分别是负责用 TCP 协议收发数据的部分和负责用 UDP 协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。关于 TCP 和 UDP 我们将后面讲解，现在只要了解：像浏览器、邮件等一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用 UDP。

​	下面一半是用 IP 协议控制网络包收发操作的部分。在互联网上传送数据时，数据会被切分成一个个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责。此外，IP 中还包括 ICMP 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

​	IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。



#### 套接字的实体就是通信控制信息

​	协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息。例如通信对象的 IP 地址、端口号、通信操作的进行状态等。本来套接字只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。

​	套接字中记录用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。

​	下面来看看真正的套接字，在 Windows 中可以用 netstate 命令显示套接字内容。图中每一行相当于一个套接字，当创建套接字时，就会在这里增加一行新的控制信息，赋予 即将开始通信 的状态，并进行通信的准备工作，如分配用于存放临时存放收发数据的缓冲区空间。

​	我们就来讲讲图上这些到底都是什么意思。比如第8行，它表示PID[插图]为4的程序正在使用IP地址为10.10.1.16的网卡与IP地址为10.10.1.18的对象进行通信。此外我们还可以看出，本机使用1031端口，对方使用139端口，而139端口是Windows文件服务器使用的端口，因此我们就能够看出这个套接字是连接到一台文件服务器的。我们再来看第1行，这一行表示PID为984的程序正在135端口等待另一方的连接，其中本地IP地址和远程IP地址都是0.0.0.0，这表示通信还没开始，IP地址不确定

> 备注：
> PID: Process ID (进程表示符)的缩写，是操作系统为了标识程序而分配的编号，使用任务管理器可以查询所对应的应用程序名称。

![image-20220311144258864](http://static.wollens.top/image-20220311144258864.png)

#### 调用 socket 时的操作

​	看过套接字的具体样子之后，接下来我们看看当浏览器调用 socket、connect 等 Socket 库中的程序组件时，协议栈内部是如何工作的。

​	首先，我们再来看一下浏览器通过 Socket 库向协议栈发出委托的一系列操作（图2.3）。正如我们之前讲过的那样，浏览器委托协议栈使用 TCP 协议来收发数据，因此下面的讲解都是关于 TCP 的。

​	首先调用 gethostbyname 获取域名对应的 IP 地址， 然后创建套接字阶段，如图2.3①所示，应用程序调用socket申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。

​	在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间，这相当于为控制信息准备一个容器。但光一个容器并没有什么用，还需要往里面存入控制信息。套接字刚刚创建时，数据收发操作还没有开始，因此需要再套接字的内存空间中写入表示这一初始状态的控制信息。到这里，创建套接字的操作就完成了。

![image-20220311145958456](http://static.wollens.top/image-20220311145958456.png)

​	接下来，需要将表示这个套接字的描叙符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌。收到描述符后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信。



### 连接服务器

#### 连接是什么

​	创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈会讲本地的套接字与服务器套接字进行连接，连接实际上是通信双方交换控制信息，在套接字中的记录这些必要信息并准备数据收发的一连串操作。

​	网线是一直连接着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这一操作随时都可以进行。不过，在这个时间点，也就是套接字刚刚创建完成时，当应用程序委托发送数据的时候，协议栈会如何操作呢？

​	套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。浏览器可以根据网址来查询服务器 IP 地址，而且根据规则也知道应该使用 80 号端口，但只有浏览器知道这些必要的信息是不够的，因为在调用 socket 创建套接字时，这些信息并没有传递给协议栈。因此，我们需要把服务器的 IP 地址和端口号等信息告知协议栈，这是连接操作的目的之一。

​	服务器上也会创建套接字【服务器程序一般会在系统启动时就创建套接字并等待客户端连接】，但服务器上的协议栈和客户端一样，之创建套接字时不知道应该和谁进行通信的。而且，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没办法开始通信。于是，我们需要让客户端向服务器告知必要的信息，比如 "我想和你开始通信，我的 IP 地址是 x x x，端口是 yyy"。可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。

​	连接实际上是通信双方交换控制信息，在套接字记录这些必要信息并准备数据收发的一连串操作，像上面提到的客户端将 IP 地址和端口号告知服务器这样的过程就属于交换控制信息的一个具体例子。所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP 地址和端口号就是典型的例子。除此之外还有其他一些控制信息，后面会继续介绍。连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备。此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。

#### 负责保存控制信息的头部

​	之前我们说的控制信息其实可以大体分为两类

​	第一类是客户端和服务器互相联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程都需要，这些内容在 TCP 协议的规格中进行了定义。网络包中没有实际的数据，只有控制信息。这些控制信息位于网络包的开头，因此被称为头部。此外，以太网和 IP 协议也有自己的控制信息，这些信息也叫头部，为了避免各种不同的头部产生混淆，我们一般会记作 TCP 头部、以太网头部、IP 头部。

​	TCP 头部信息格式

![image-20220313214912038](http://static.wollens.top/image-20220313214912038.png)

​	控制信息还有另外一类，那就是保存在套接字中，用来控制协议栈操作的信息。应用程序传递来的消息以及通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也保存在这里，协议栈会根据这些信息来执行每一步操作。我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，协议栈具体需要那些信息会根据协议栈本身的实现方式不同而不同，但这并没有什么问题，因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。我们无法具体说明协议栈里到底保存了那些控制信息，但可以用命令来显示一些重要的套接字控制信息，这些信息无论何种操作心痛的协议栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式啦。

![image-20220313215928864](http://static.wollens.top/image-20220313215928864.png)

> 总结：通信操作中使用的控制信息分为两类
>
> 1. 头部中记录的信息
> 2. 套接字（协议栈中的内存空间）中记录的信息



#### 连接操作的实际过程

我们已经了解连接操作的含义，下面来看一下具体的操作过程。这个过程是从应用程序调用 Socket 库的 connect 开始。

```shell
connect(<描叙符>，<服务器IP地址和端口号>，...)
```

上面的调用提供了服务器 IP 地址和端口号。这些信息会传递给协议栈中的 TCP 模块，然后，TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换信息，这一交互过程包括以下几个步骤。首先，客户端会创建一个包含表示开始数据收发操作的控制信息的头部。头部包含很多字段，这里要关注的重点是发送方和接收方的端口号。这里，客户端（发送方）的套接字就准确找到服务器（接收方）的套接字，也就搞清楚了我应该连接哪个套接字，然后我们将头部中的控制位的 SYN 比特设置为1，大家可以认为它表示连接。此外还需要设置适当的序号和窗口大小，这一点后面会详细讲解。

> 连接操作的第一步是在 TCP 模块出创建表示连接信息的头部。
>
> 通过 TCP 头部中的发送方和接收方端口号可以找到要连接的套接字

当 TCP 头部创建号之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送。IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的 IP 模块会将接到的数据传递给 TCP 模块，服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字，也就是说，从出于等待连接状态的套接字中找到与 TCP 头部记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的 TCP 模块会返回响应，这个过程和客户端一样，需要在 TCP 头部设置发送方和接收方端口号以及 SYN 比特。此外，在返回响应时还需要将 ACK 控制位设为 1，这表示已经接收到相应的网络包。网络中经常发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置 ACK 比特就是用来进行这一确认的。接下来，服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回相应。

然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功。如果 SYN 为1则表示连接成功，这是会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕。到这里，客户端的操作已经完成，但其实还剩最后一个步骤。刚才服务器返回的相应时将 ACK 比特设置为1，相应地，客户端也需要将 ACK 比特设置为1并发回服务器，告诉服务器刚才的相应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。

现在，套接字就已经进入随时可以收发数据的状态了，大家可以认为这是有一根管子把两个套接字连接起来。当然实际上并没有这么一根管子，不过这样想比较容易理解。这根管子，我们称为连接，只要数据传输过程在持续，也就是调用 close 断开之前，连接是一直存在的。

建立连接之后，协议栈的连接操作就结束了，也就是说 connect 已经执行完毕，控制流程被交回到应用程序。

### 收发数据

#### 将 HTTP 请求消息交给协议栈

​	当控制流程从 connect 回到应用程序之后，接下来就进入数据收发阶段了。数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的，协议栈收到数据后执行发送操作，协议栈收到数据后执行发送操作，这一操作包含如下要点。

​	首先，协议栈并不关心应用程序传来的数据是什么内容。应用程序在调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。

​	其次，协议栈并不是已收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。这样做是有道理的。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同，这些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据。总之，一次奖多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。在这样的情况下，如果一收到数据就马上发送出去，就可能会发生大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。至于要积累多少数据发送，不同种类和版本的操作系统会有所不同，不能一概而论。但都是根据下面几个要素来判断的。

​	第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫 MTU（Maximum Transmission Unit，最大传输单元）的参数来进行判断。MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节。MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫做 MSS（Maximum Segment Size，最大分段大小。TCP 和 IP 的头部加起来一般是40字节，因此 MTU 减去这个长度就是 MSS）。当从应用程序收到的数据长度超过或者接近 MSS 时在发送出去，就可以避免发送大量小包问题了。

> MTU: 一个网络包最大长度，以太网中一般为 1500 字节。
>
> MISS: 除去头部之后，一个网络包所能容纳的 TCP 数据的最大长度

​	另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓存区中的数据长度没有达到 MISS，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。

​	判断要素就是这两个，但它们其实是相互矛盾的。如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；相反的，如果时间优先，那么延迟时间会变少，但会降低网络的效率。因此，在进行发送操作时需要综合考虑这两个要素达到平衡。不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。

​	正如前面所说，如果仅靠协议栈来判断发送的时机会带来一些问题，因此协议栈也给应用程序保留了发送时机的余地。应用程序在发送数据时可以指定一些选线，比如如果指定 不等待填满缓冲区直接发送，则协议栈就会按照要求直接发送数据。像浏览器这种回话的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会直接发送数据的选项。

![image-20220314215236453](http://static.wollens.top/image-20220314215236453.png)

- 起始帧分界符：Start Frame Delimiter，SFD。
- FCS：Frame Check Sequence，帧校验序列

#### 对较大的数据进行拆分

HTTP 请求消息一般不会很长，一个网络包就能装下，但如果其中要提交表单数据，长度就可能超过一个网络包所容纳的数据量，比如在博客或者论坛上发表一篇长文就属于这种情况。

这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这是我们当然不需要继续等待后面的数据。发送缓冲区中的数据会被以 MSS 长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。

根据发送缓冲区中的数据拆分情况，当判断需要发送这些数据时，就在每一块数据前面加上 TCP 头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号，然后交给 IP 模块来执行发送数据的操作。

![image-20220318172033429](http://static.wollens.top/image-20220318172033429.png)

应用程序的数据一般比较大，因此 TCP 会按照网络包的大小对数据进行拆分。



### 使用 ACK 号确认网络包已收到

到这里，网络包已经装好数据并发往服务器，但数据发送操作还没有结束。TCP 具备确认对方是否成功收到网络包，以及赌坊没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认。

我们先来看一下确认的原理。首先，TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时， 将算法的字节写在 TCP 头部中，序号 字段就是派在这个用场上的。然后，发送数据长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法进行计算。有了上面两个数值，我们就可以知道发送数据是从第几个字节开始，长度是多少。

通过这些信息，接收方还能够检查接收的网络包有没有遗漏。例如，假设上次接收到第1460字节，那么接下来如果收到序号为1461的包，说明中间没有遗漏；但如果收到的包序号为 2921，那就说明中间有包遗漏了。像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经接收到多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方【返回 ACK 号时，除了要设置 ACK 号的值外，还需要将控制为中的 ACK 比特设置为1，这代表 ACK 号字段有效，接收方就可以知道这个网络包是用来告知 ACK 号】。简单来说，发送发说的是 想在发送的是从第 xx 字节开始的部分，一共有 xx 字节，而接收方则回复说：到第 xx 字节之前到数据我已经收到了，这个返回的 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到多少数据。

然而，图2-7的例子和实际情况还是有些出入的。在实际的通信中，序号并不是从1开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从1开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。大家应该还记得我们刚才讲过在连接过程中，有一个 SYN 控制位设为 1 并发送给服务器的操作，就是在一步将序号的初始值告知对方的。实际上，在将 SYN 设为1的同时，还需要同时设置序号字段的值，而这里的值就是代表序号的初始值

<img src="http://static.wollens.top/image-20220319094252583.png" alt="image-20220319094252583" style="zoom:67%;" />

前面介绍了通过序号和 ACK 号来进行数据确认的思路，但仅凭这些还不够，因为我们刚刚只考虑了单向的数据传输，但TCP数据收发是双向的，在客户向像服务器发送数据的同时，服务器也会向客户端发送数据，因此必须要想办法应对这样的情况。不过，这其实也不难，图 2-7 中展示的客户端向服务器发送数据的情形，我们只需要增加一种左右相反的情形就可以，如图 2-8 所示。首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算 ACK 号并返回给客户端；相反的服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算 ACK 号并返回给服务器。此外，如图所示，客户端和服务器双方都需要各自计算序号，因此双发需要在连接过程中互相告知自己计算的序号初始值。

![image-20220319095127183](http://static.wollens.top/image-20220319095127183.png)

明白原理之后我们来看一下实际的工作过程（图2-9）。首先，客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器。接下来，服务器会通过这个初始值计算出 ACK 号并返回给客户端（1），接下来，服务器会通过这个初始值计算出 ACK 号并返回给客户端（2）。初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回 ACK 号作为确认。同时，服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值，并将这个值发送给客户端（2）。接下来像刚才一样，客户端也需要根据服务器发来的初始值计算出 ACK 号并返回给服务器（3）。到这里，序号和 ACK 号都已经准备完成，接下来就可以进入数据收发阶段。数据收发操作本身是可以双向同时进行的，但 Web 中是先由客户端向服务器发送请求，序号也会跟随数据一起发送（4）。然后，服务器收到数据后在返回 ACK 号（5）。从服务器向客户端发送数据的过程则正好相反（6 7）

![image-20220319100139660](http://static.wollens.top/image-20220319100139660.png)

TCP 采用这样的方式确认对方是否接收到数据，在得到对方确认前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包。

这一机制非常强大。通过这一机制，我们可以确认接收方有没有接收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。

因此，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。应用程序也是一样，因为采用 TCP 传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好。不过，如果发生网络中断、服务器宕机等问题，那么无论 TCP 怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此 TCP 会在尝试几次重传无效之后强制借宿通信，并向程序报错。

> 通过 "序号" 和 ""ACK 号" 可以确认接收方是否收到网络包。



#### 根据网络包平均往返时间调整 ACK 号等待时间

前面说的只是一些基本原理，实际上网络的错误检测和补偿机制非常复杂。下面来说几个关键点，首先是返回 ACK 号等待时间（这个等待时间叫超时时间）

当网络传输繁忙时就会发生拥塞，ACK 号的返回会变慢，这是我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的 ACK 号才姗姗来迟的情况。这样的重传是多余的，看上去只是发一个包而已，但它造成的后果没那么简单。因为 ACK 号的返回变慢大多是由于网络拥塞引起的，因此如果此时在出现很多多余的重传，对于本来就很拥塞的网络来说无疑是雪上加霜。那么等待时间是不是越长越好？也不是。如果等待时间长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。

看来等待时间需要设为一个合适的值，不能太长也不能太短，但这谈何容易。根据服务器物理距离的远近，ACK 号的返回时间也会产生很大的波动，而且我们还必须考虑到拥塞带来的影响。例如，在公司里的局域网环境下，几毫秒才能返回 ACK 号并不稀奇。

正因为波动如此之大，所以等待时间设置为一个固定值并不是一个好办法。因此，TCP 采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需时间来判断。具体来说，TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地如果 ACK 号马上就能返回，则相应缩短等待时间。

#### 使用窗口有效管理 ACK 号

如图 2.10(a) 所示，每发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在是太浪费，为了减少这样的浪费，TCP 采用 2.10(b) 这样的滑动窗口方式来管理数据发送和 ACK 的操作。所谓滑动窗口，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。这样一来等待 ACK 号的这段时间就别有效利用起来了。

![image-20220319213534184](http://static.wollens.top/image-20220319213534184.png)

虽然这样做能够减少等待 ACK 号时的时间浪费，但有一些问题需要注意。在一来一回方式中，接收方完成接收操作后返回 ACK 号，然后发送方接收到 ACK 号后才能继续发送下一个包，因此不会出现发送的包太多接收方处理不过来的情况。但如果不等待返回 ACK 号就连续发包，就有可能会出现发送包的频率超过接收方处理能力的情况。

下面对该情况具体解释一下。当接收方的 TCP 收到包后，会先讲数据存放到接收缓冲区中，然后，接收方需要计算 ACK 号，将数据快组装起来还原成原来的数据并传递给应用程序。如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。缓冲区溢出之后，后面的数据就进不来，因此接收方就收不到后面的包，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。我们可以通过下面的方法来避免这种情况发生。首先，接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思想。

关于滑动窗口的具体工作方式，还是看图更容易理解（图2.11）。这张图中，接收方将数据暂存到接收缓冲区中并执行接收操作。当接收操作完成后，接收缓冲区中的空间会被释放出来，也就可以接收更多的数据，这时接收方会通知 TCP 头部中的窗口字段将自己能接受的数据量告知发送方。这样一来，发送方就不会发送过多的数据，导致超出接受方的处理能力。

此外，单从图上看，大家可能会以为接受方在等待接受缓冲区被填满之前似乎什么都没做，实际上并不是这样。这张图是为了讲解方便，故意体现一种接受方来不及处理收到的包，导致缓冲区被填满的情况。实际上，接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。

还有，图 2.11 中只显示了从右往左发送数据的操作，实际上和序号、ACK 号一样，发送操作也是双向进行的。

<img src="http://static.wollens.top/image-20220319215829656.png" alt="image-20220319215829656" style="zoom:67%;" />

#### ACK 与窗口的合并

更新窗口大小的时机应该是接收应该是接收方从缓冲区中取出来数据传递给应用程序的时候。这个操作是接收方应用程序发出请求是才回进行，而发送方不知道什么时候回进行这样的操作，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。

接收方在发送 ACK 号和窗口更新时，并不会马上把包发送出去，而是等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送。举个例子，在等待发送 ACK 号的时候正好需要更新窗口，这是就可以把 ACK 号和窗口更新放在一个包里发送，从而减少包的数量，这是因为 ACK 号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据最后为止在哪里，因此当需要连续发送 ACK 号时，只要发送最后一个 ACK 号就可以了，中间的可以省略。当需要连续发送多个窗口更新时也可以减少包的数量，因为连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加。这种情况和 ACK 号一样，可以省略中间过程，只要发送最终的结果就可以。



#### 接收 HTTP 响应消息

浏览器在委托协议栈发送请求消息之后，会调用 read 程序来获取响应消息。然后，控制流程会通过 read 转移到协议栈，然后协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下：

首先协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这是，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。

> 总结：首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号。然后协议栈将数据块暂存到接收缓冲区中，并将数据按块顺序连接起来还原原始的数据，最后将数据交给应用程序。具体来说，协议栈会将接收到的数据复制到应用程序制定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新