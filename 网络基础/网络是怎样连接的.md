# 网络是怎样连接的

## 浏览器生成的消息 —— 探索浏览器内部

### 生产 HTTP 请求消息

### 向 DNS 服务器查询 Web 服务器的 IP 地址

#### IP 地址的基础知识

​    生成 HTTP 消息之后，接下来我们需要委托操作系统将消息发送给 Web 服务器【浏览器能够解析网址并生成 HTTP 消息，但它本身不具备发到网络的功能】，在进行这一操作时，我们还有一个工作需要完成，就是查询网址中服务器域名对应的 IP 地址。在委托操作系统发送消息时，必须要提供请求服务器的 IP 地址。因此下一个步骤是根据域名查询 IP 地址。

​	互联网和公司内部的局域网都是基于 TCP/IP 的思路来设计的，所以我们需要先了解 TCP/IP 的基本思路，如下图所示。

​	在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的 xx号xx室。其中 号 对应的号码是分配给整个子网的，而 室 对应的号码是分配给子网中的计算机的，这就是网络中的地址。号 对应的号码称为网络号，室 对应的号码称为主机号，这个地址整体称为 IP 地址。通过 IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。

![image-20220308220121337](http://static.wollens.top/image-20220308220121337.png)

实际 IP 地址是一串 32 比特的数字，按照 8 比特（1个字节）为一组分成四组，分别用十进制表示然后再用圆点隔开。这就是我们平时常见的 IP 地址格式，但是仅凭一串数字我们无法区分那部分是网络号，那部分是主机号。在 IP 地址的规则中，网络号和主机号连起来共识 32 比特，蛋这两部分的具体结构是不固定的。在组建网络是，用户可以自行决定它们之间的分配关系，因此我们还需要另外的附加信息来表示 IP 地址的内部结构

<img src="http://static.wollens.top/image-20220308221224656.png" alt="image-20220308221224656" style="zoom:50%;" />

子网掩码的格式如下图所示，是一串与 IP 地址长度相同的 32 比特数字，其左边一半都是1，右边一半都是0。其中子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。

<img src="http://static.wollens.top/image-20220308222308302.png" alt="image-20220308222308302" style="zoom:50%;" />

> 备注：主机号部分的比特全部为 0 或者全部为 1 时代表两种特许的含义。主机号部分全部为 0 代表整个子网而不是子网中的某台设备。主机号全部为1代表向子网上所有的设备发送包，即广播



#### 域名和IP地址并用的理由

​	TCP/IP 网络是通过 IP 地址来确定通信的对象，因此不知道 IP 地址就无法将消息发送给对方，因此，在委托操作系统发送消息是，必须要先查询号对方的 IP 地址。

​	既然需要通过域名来查找服务器 IP，那为啥不直接使用 IP 地址访问？实际上，如果用 IP 地址代替服务器名称也是能够正常工作的。然而记一串 IP 地址比较困难，因此相比 IP 地址，网址中使用域名形式访问还是会比较好。

​	现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，这样就能够在任何机器双方都不做出牺牲的前提下完美解决问题，这个机制就是 DNS



#### Socket 库提供查询 IP 地址的功能

​	通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫做解析器。解析器实际上是一段程序，他饱含在操作系统的 Socket 库中，在介绍解析器之前，我们先来简单了解一下 socket 库。首先，库到底是什么东西？库就是一对通用程序组件的集合，其他的应用程序都需要使用其中的组件。库有很多好处。首先，使用线程的组件搭建应用程序可以节省编程工作量；其次，多个程序使用相同的组件可以实现程序的标准化。Socket 库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是合格库中的其中一种程序组件。



#### 通过解析器向 DNS 服务器发出查询

​	解析器的用法非常简单。Socket 库中的程序都是标准组件，只要从应用程序中进行调用就可以。具体来说，在编写浏览器等应用程序的时候，只要想下图所示协商解析器程序名称 "gethostbyname" 以及 Web 服务器的域名 "www.lab.glasscom" 就可以，这样就完成了对解析器的调用。

<img src="http://static.wollens.top/image-20220309153129375.png" alt="image-20220309153129375" style="zoom:50%;" />

​	在应用程序中编写上图中的一行代码后就能够调用解析器完成向 DNS 服务器查询 IP 地址的操作。

​	调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回相应消息。响应消息中包含查询到的 IP 地址，解析器会取出 IP 地址，并将其写入浏览器指定的内存地址中，只要运行上图中这一行程序，就可以完成前面所有这些工作，我们也就完成了 IP 地址的查询。接下来，浏览器在向 Web 服务器发送消息时，你要从该内存中取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以。



#### 解析器的内部原理

​	下面来看一看应用程序调用解析器时，解析器内部是如何工作的。解析器内部工作原理如下：

<img src="http://static.wollens.top/image-20220309154012630.png" alt="image-20220309154012630" style="zoom:67%;" />

​	一般来说，应用程序编写的操作内容是从上往下按顺序执行的，当到达需要调用解析器的部分时，对应的那一行程序就会被执行，应用程序本身的工作就会暂停（图1.12①）。然后，Socket库中的解析器开始运行（图1.12②），完成应用程序委托的操作。像这样，由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行，这就是“控制流程转移”[插图]。当控制流程转移到解析器后，解析器会生成要发送给DNS服务器的查询消息。这个过程与浏览器生成要发送给Web服务器的HTTP请求消息的过程类似，解析器会根据DNS的规格，生成一条表示“请告诉我www.lab.glasscom.com的IP地址”[插图]的数据，并将它发送给DNS服务器（图1.12③）。发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈[插图]来执行。这是因为和浏览器一样，解析器本身也不具备使用网络收发数据的功能。解析器调用协议栈后，控制流程会再次转移，协议栈会执行发送消息的操作，然后通过网卡将消息发送给DNS服务器（图1.12④⑤）。

​	当DNS服务器收到查询消息后，它会根据消息中的查询内容进行查询。这个查询的过程有点复杂，我们稍后会进行讲解，这里先不关心具体的方法。总之，如果要访问的Web服务器已经在DNS服务器上注册，那么这条记录就能够被找到，然后其IP地址会被写入响应消息并返回给客户端（图1.12⑥）。接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器（图1.12⑦⑧），然后解析器读取出消息取出IP地址，并将IP地址传递给应用程序（图1.12⑨）。实际上，解析器会将取出的IP地址写入应用程序指定的内存地址中，图1.11用“<内存地址>”来表示，在实际的程序代码中应该写的是代表这一内存地址的名称。

​	到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器）。现在应用程序已经能够从内存中取出 IP 地址了，所以说 IP 地址是用这种方式传递给应用程序的。

​	计算机中的内部结构是一层一层的，也就是说，很多程序组成不同的层次，彼此之间分工协作，当接到上层委派的操作时，本层的程序并不完成所有的工作，而是会完成一部分工作，再将剩下的部分委派到下层来完成。

​	顺带一提，向 DNS 服务器发送消息时，我嗯当然也需要知道 DNS 服务器的 IP 地址，只不过这个 IP 地址是作为 TCP/IP 的一个设置项目实现设置好的，不需要再去查询。不同操作系统中 TCP/IP 的设置方法也有差异，Windows 中的设置如图所示，解析器会根据这里设置的 DNS 服务器 IP 地址来发送消息

<img src="http://static.wollens.top/image-20220309155212245.png" alt="image-20220309155212245" style="zoom:50%;" />

### 全世界 DNS 服务器大接力

#### DNS 服务器的基本工作

​	前面介绍了解析器与 DNS 服务器之间的交互过程，下面了解一下 DNS 服务器的工作。DNS 服务器的基本工作就是接受来自客户端的查询消息，然后根据消息的内容返回相应

​	其中，来自客户端的查询消息包含一下3中信息

 1. 域名

    服务器、邮件服务器（邮件地址中@后面的部分）的名称

 2. Class

    在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而 Class 就是用来标识网络的信息，不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN

 3. 记录类型

    表示域名对应何种类型的记录，例如：当类型为 A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同

​	DNS 服务器上事先保存有前面这 3 种信息对应的记录数据，如下图所示。DNS 服务器就是根据和谐记录查找符合查询请求的内容并对客户端作出相应的

<img src="http://static.wollens.top/image-20220309160117576.png" alt="image-20220309160117576" style="zoom:67%;" />

总结：DNS 服务器的基本工作原理就是根据需要查询的域名和记录类型查找相关的记录，并向客户端返回响应消息。

​	前面只介绍 A 和 MX 这两个记录类型，实际上还有很多其他的类型。例如根据 IP 地址反查域名和 PTR 类型，查询域名相关别名的 CNAME 类型，查询 DNS 服务器 IP 地址的 NS 类型，以及查询域名属性信息的 SOA 类型等。尽管 DNS 服务器的工作原理很简单，不过是根据查询消息中的域名和记录类型来进行查找并返回响应信息而已，但通过组合使用不同的记录类型，就可以处理各种各样的信息。此外，虽然图中展示的是表格形式，但实际上这些信息是保存在配置文件中的，表格中的一行信息被称为一条资源记录。



#### 域名的层次结构

​	互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台服务器中是不可能的，因此一定会出现 DNS 服务器找不到要查询的信息的情况。下面来看一看此时 DNS 服务器是如何工作的。

​	直接说出答案其实很简单，就是将信息分布保存在多台 DNS 服务器中，这些 DNS 服务器相互接力配合，从而查出要查询的信息。不过这个机制其实有点复杂，因此我们先来看一看信息是如何在 DNS 服务器上注册保存的。

​	首先，DNS 服务器中的所有信息都是按照区域以分层的结构来保存的。层次结构这个词听起来可能有点不容易懂，其实就是类似公司中的事业集团、部门、科室这样的结构。层次结构能够帮组我们更好的管理大量的信息。

​	DNS中的域名都是用句点来分隔的，比如www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已[插图]。在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。其中，相当于一个层级的部分称为域。因此，com域的下一层是glasscom域，再下一层是lab域，再下面才是www这个名字。

​	DNS中的域名都是用句点来分隔的，比如www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已[插图]。在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。其中，相当于一个层级的部分称为域。因此，com域的下一层是glasscom域，再下一层是lab域，再下面才是www这个名字。



#### 寻找响应的 DNS 服务器并获取 IP 地址

​	下面再来看一看如何找到 DNS 服务器中存放的信息，这里的关键在于如何找到我们要访问的Web服务器的信息跪哪一台DNS服务器管。

​	互联网中有数万台DNS服务器，肯定不能一台一台挨个去找。我们可以采用下面的办法。首先，将负责管理下级域的DNS服务器的IP地址注册到它们的上级DNS服务器中，然后上级DNS服务器的IP地址再注册到更上一级的DNS服务器中，以此类推。也就是说，负责管理lab.glasscom.com这个域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，而glasscom.com域的DNS服务器的IP地址又需要注册到com域的DNS服务器中。这样，我们就可以通过上级DNS服务器查询出下级DNS服务器的IP地址，也就可以向下级DNS服务器发送查询请求了。

​	在前面的讲解中，似乎com、jp这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS服务器的信息，但实际上并非如此。在互联网中，com和jp的上面还有一级域，称为根域。根域不像com、jp那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像www.lab.glasscom.com．这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的DNS服务器中保管着com、jp等的DNS服务器的信息。由于上级DNS服务器保管着所有下级DNS服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的DNS服务器。

​	除此之外还需要完成另一项工作，那就是将根域的DNS服务器信息保存在互联网中所有的DNS服务器中。这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器了。因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器（图1.15）。分配给根域DNS服务器的IP地址在全世界仅有13个[插图]，而且这些地址几乎不发生变化，因此将这些地址保存在所有的DNS服务器中也并不是一件难事。实际上，根域DNS服务器的相关信息已经包含在DNS服务器程序的配置文件中了，因此只要安装了DNS服务器程序，这些信息也就被自动配置好了。

​	到这里所有的准备工作都完成了，当我们配置一台 DNS 服务器时，必须要配置好上面这些信息，这样 DNS 服务器就能够从上万台 DNS 服务器中找到目标服务器。下图展示这个过程是如何进行的

<img src="http://static.wollens.top/image-20220309170832901.png" alt="image-20220309170832901" style="zoom:50%;" />

​	如下图所示：客户端首先会访问最近的一台DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址），假设我们要查询www.lab.glasscom.com这台Web服务器的相关信息（图1.16①）。由于最近的DNS服务器中没有存放www.lab.glasscom.com这一域名对应的信息，所以我们需要从顶层开始向下查找。最近的DNS服务器中保存了根域DNS服务器的信息，因此它会将来自客户端的查询消息转发给根域DNS服务器（图1.16②）。根域服务器中也没有www.lab.glasscom.com这个域名，但根据域名结构可以判断这个域名属于com域，因此根域DNS服务器会返回它所管理的com域中的DNS服务器的IP地址，意思是“虽然我不知道你要查的那个域名的地址，但你可以去com域问问看”。接下来，最近的DNS服务器又会向com域的DNS服务器发送查询消息（图1.16③）。com域中也没有www.lab.glasscom.com这个域名的信息，和刚才一样，com域服务器会返回它下面的glasscom.com域的DNS服务器的IP地址。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器（图1.16⑤），只要向目标DNS服务器发送查询消息，就能够得到我们需要的答案，也就是www.lab.glasscom.com的IP地址了。

![image-20220309171052934](http://static.wollens.top/image-20220309171052934.png)

​	收到客户端的查询消息之后，DNS服务器会按照前面的方法来查询IP地址，并返回给客户端（图1.16⑥）。这样，客户端就知道了Web服务器的IP地址，也就能够对其进行访问了（图1.16⑦）



#### 通过缓存加快 DNS 服务器的响应

​	图1.16展示的是基本原理，与真实互联网中的工作方式还是有一些区别的。在真实的互联网中，一台DNS服务器可以管理多个域的信息，因此并不是像图1.16这样每个域都有一台自己的DNS服务器。图中，每一个域旁边都写着一台DNS服务器，但现实中上级域和下级域有可能共享同一台DNS服务器。在这种情况下，访问上级DNS服务器时就可以向下跳过一级DNS服务器，直接返回再下一级DNS服务器的相关信息。

​	此外，有时候并不需要从最上级的根域开始查找，因为DNS服务器有一个缓存[插图]功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。

​	这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。因此，DNS服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。而且，在对查询进行响应时，DNS服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的DNS服务器。



### 委托协议栈发送消息

#### 数据首发操作概览

​	知道 IP 地址后，就可以委托操作系统内部的协议栈向这个目标 IP 地址（web 服务器）发送消息。要发送给 web服务器的 HTTP 消息是一种数字信息，因此也可以说是委托协议栈发送数字信息。

​	和向 DNS 服务器查询 IP 地址的操作一样，这里也需要使用 Socket 库中的程序组件，不过这里需要按照顺序调用多个程序组件，这个过程有点复杂，我们先介绍一下收发数据操作的整体思路

​	使用 Socket 库来收发数据的操作如下图所示，简单来说，收发数据的两台计算机之间连接了一条双向数据通道，数据沿着这条通道流动，最终到达目的地。

<img src="http://static.wollens.top/image-20220309232012721.png" alt="image-20220309232012721" style="zoom:67%;" />

​	收发数据的整体思路是这样的，但还有一点也非常重要。光从图上来看，这条管道好像一开始就有，但实际上并不是这样，在进行收发数据操作之前，双发需要先建立这条管道。建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将台接字连接起来形成管道。实际过程是下面这样的。首先，服务器一方会先创建套接字，然后等待客户端向该套接字连接管道。当服务器进入等待状态时，客户端就可以连接管道。具体来说，客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务端的套接字上。当双方的套接字连接起来之后，通信准备就完成了。接下来，只要将数据送入套接字就可以收发数据了。

​	我们再来看一看收发数据操作结束时的情景。当数据全部发送完毕之后，连接的管道将会被断开。管道在连接时又客户端发起，但在断开时可以有客户端或服务端任意一方发起，其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。到此为止，通信操作就结束了。ß

​	综上所述，收到数据的操作可以大致分为一下4个：

 	1. 创建套接字（创建套接字阶段）
 	2. 将管道连接到服务端的套接字上（连接阶段）
 	3. 收发数据（通信阶段）
 	4. 断开管道并删除套接字（断开阶段）

​	在每个阶段，Socket 库中的程序组件都会被调用来执行相关的数据收发操作。前面这4个操作都是有操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、收入数据这些工作，而是委托协议栈代劳。



#### 创建套接字阶段

​	下面我们来探索一下应用程序（浏览器）委托收发数据的过程。

​	首先是套接字创建阶段。客户端创建套接字非常简单，只要调用 Socket 库中的 socket 程序组件就可以。和调用解析器一样，调用 socket 之后，控制流程会转移到 socket 内部执行创建套接字的操作，完成之后流程又会被移交回应用程序。只不过，socket 的内部操作并不像解析器那样简单，后面会有详细讲解，现在大家只要知道调用 socket 后套接字就创建好就可以。

​	套接字创建完成后，协议栈回返回一个描叙符，应用程序会将收到的描叙符存放在内存中。描述符是用来识别不同的套接字。因为同一台机器可能同时访问多个网页，可能同时存在多个套接字，在这种情况下，我们需要识别出某个特定的套接字，这种方法就是描述符。我们可以将描述符理解成给某个套接字分配的编号。当创建套接字后我们就可以使用这个套接字来执行收发数据的操作。这是我们出示描述符，协议栈就能够判断出我们希望用那一个套接字来连接或者收发数据。

![image-20220310151229430](http://static.wollens.top/image-20220310151229430.png)

内部分为：创建套接字、连接 Web 服务器、发送数据、接受数据、断开连接几个阶段ß



> 备注：书中出现的 Socket、socket、套接字看起来很容易混淆，其中小写的 socket 表示程序组件的名称，大写字母开头的 Socket 表示库，而汉字 套接字 则表示管道两端的借口



#### 连接阶段：把管道连接上去

​	接下来，我们需呀委托协议栈将客户端创建的套接字于服务器那边的套接字连接起来。应用程序通过调用 Socket 库中 connect 组件来完成这一操作。这里的要点是当调用 connect 时，需要指定描叙符、服务器 IP 地址和端口号这3个参数。

​	第一个参数：描述符，就是在创建套接字的时候由协议栈返回的那个描述符。connect 会讲应用程序追定的描述符告知协议栈，然后协议栈根据这个描叙符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接操作。

​	第二个参数：即服务器 IP 地址，就是通过 DNS 服务器查询得到的我们要访问的服务器 IP 地址。

​	第三个参数：即端口号，IP 地址是为区分网络中的各个计算机而分配的数值，因此只知道 IP 地址，我们就可以识别出网络上的某台计算机。但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址是无法做到这一点的。当同时指定 IP 和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。描述符是和委托创建套接字的应用程序交互时使用的，并不是用来告诉网络连接的另一方，因此另一方并不知道这个描述符。所以我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。如果说描叙符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。

​	既然需要通过端口号来确定连接对象的套接字，但是网址中好像并没有端口号，也不能像 IP 地址一样去问 DNS 服务器。其实服务器上使用的端口号是根据应用的种类事先规定好的。比如：Web 默认是 80 端口，电子邮件默认是 25 号端口。关于端口号后面还会继续介绍。

​	大家可能有个疑问，既然确定连接对象的套接字需要使用端口号，那么服务器套接字也得得知客户端的端口号才行吧，这个问题是如何解决的，事情是这样的，首先客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随机分配的端口号通知给服务器，这部分内容我们后面会在第2章探索协议栈内部工作时进行介绍

​	总结：当调用 Socket 中 connect 组件时，协议栈会执行连接操作。当连接成功后，协议栈后会将对方的 IP 地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。



#### 通信阶段：传递消息

​	当套接字连接之后，只要将数据送入套接字，数据就会被发送到对方的套接字中，这个过程还是要通过 Socket 库委托协议栈来完成这个操作。这个操作需要使用 write 这个程序组件，具体过程如下：

​	首先，应用程序需要在内存中准备好要发送的数据。根据用户输入的网址生成的HTTP请求消息就是我们要发送的数据。接下来，当调用write时，需要指定描述符和发送数据（图1.18③），然后协议栈就会将数据发送到服务器。由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。接着，发送数据会通过网络到达我们要访问的服务器。接下来，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息。

​	当消息返回后，需要执行的是接收消息的操作。接收消息的操作是通过Socket库中的read程序组件委托协议栈来完成的（图1.18③'）。调用read时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。于是，当服务器返回响应消息时，read就会负责将接收到的响应消息存放到接收缓冲区中。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。



#### 断开阶段：收发数据结束

​	当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket库的close程序组件进入断开阶段（图1.18④）。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。

​	断开的过程如下。Web使用的HTTP协议规定，当Web服务器发送完响应消息之后，应该主动执行断开操作[插图]，因此Web服务器会首先调用close来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用read执行接收数据操作时，read会告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用close进入断开阶段。

​	这就是HTTP的工作过程。HTTP协议将HTML文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在HTTP版本1.1中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。



## 用电信号传输 TCP/IP —— 探索协议栈网卡

![image-20220310190756903](http://static.wollens.top/image-20220310190756903.png)

1. 创建套接字

   从应用程序收到委托后，协议栈通过 TCP 协议收发数据的操作可以分为4个阶段，首先是创建套接字，在这个阶段我们将介绍协议栈内部结构、套接字的实体，以及创建套接字的操作过程。到这里大家应该可以对套接字到底是什么样一个东西有一个比较具体的理解。

2. 连接服务器

   接下来是客户端套接字向服务器套接字进行连接的阶段，我们将介绍 连接 具体是进行怎样的操作，在这个过程中协议栈到底是如何工作的，以及客户端和服务器是如何进行交互的。

3. 收发数据

   两端的套接字完成连接之后，就进入收发消息阶段。在这个阶段协议栈会将应用程序收到的数据切成小块并发送给服务器，考虑到通信过程可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送到服务器，对于没有送达的包要重新发送一次。这里我们将对收发数据的情形加以说明

4. 从服务器断开连接并删除套接字

   收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。断开操作的本质是当消息收发完成后客户端和服务器互相确认的过程，但这个过程并不只是相互确认并删除套接字那么简单，其中有些地方是很有意思的。

5. IP 与以太网的包收发操作

   在介绍 TCP 协议收发消息的操作之后，我们再来看看实际网络包是如何进行收发的。协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。介绍完这个过程后，大家应该可以对计算机网络功能有一个完整的概念了。

6. 用 UDP 协议收发数据的操作

   TCP 协议有很多方便的功能，比如网络出错丢失时可以重发，因此很多应用程序都是使用 TCP 协议来收发数据的，单这些方便的功能也有帮倒忙的时候，在这种情况喜爱我们还有另外一种叫 UDP 的协议。这里我们将介绍 UDP 的必要性以及它与 TCP 的差异。

### 创建套接字

#### 协议栈内部结构

​	本章将探索操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何将浏览器的消息发送给服务器的。和浏览器不同的是，协议栈的工作我们从表面是看不见的。因此在实际探索前，我们先来对协议栈做解析，看看里面到底有些什么。

​	协议栈的内部如图2.1所示，分为几个部分，分别承担不同的功能。下图中的上下关系是有一点规则的。上面的部分会向下面的部分委派工作，下面的部分接受委派工作并实际执行。但这知识一个总体规则，其他也有一部分上下关系不明确，或者上下关系相反的情况。对于图中的每个部分以及他们的工作方式，本章将按顺序进行介绍。

![image-20220311115422438](http://static.wollens.top/image-20220311115422438.png)

​	上层会向下层组层委派工作。图中最上面的部分是网络应用程序，也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分完成。当然除了浏览器之外，其他应用程序在网络上收发数据的操作也都类似上面这样的，也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。因此下面介绍的内容不仅适用于浏览器同时也适用于各种应用程序。

​	应用程序下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询。

​	在下面就是操作系统内部，其中包括协议栈。协议栈的上半部分有两块，分别是负责用 TCP 协议收发数据的部分和负责用 UDP 协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。关于 TCP 和 UDP 我们将后面讲解，现在只要了解：像浏览器、邮件等一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用 UDP。

​	下面一半是用 IP 协议控制网络包收发操作的部分。在互联网上传送数据时，数据会被切分成一个个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责。此外，IP 中还包括 ICMP 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

​	IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。



#### 套接字的实体就是通信控制信息

​	协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息。例如通信对象的 IP 地址、端口号、通信操作的进行状态等。本来套接字只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。

​	套接字中记录用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。

​	下面来看看真正的套接字，在 Windows 中可以用 netstate 命令显示套接字内容。图中每一行相当于一个套接字，当创建套接字时，就会在这里增加一行新的控制信息，赋予 即将开始通信 的状态，并进行通信的准备工作，如分配用于存放临时存放收发数据的缓冲区空间。

​	我们就来讲讲图上这些到底都是什么意思。比如第8行，它表示PID[插图]为4的程序正在使用IP地址为10.10.1.16的网卡与IP地址为10.10.1.18的对象进行通信。此外我们还可以看出，本机使用1031端口，对方使用139端口，而139端口是Windows文件服务器使用的端口，因此我们就能够看出这个套接字是连接到一台文件服务器的。我们再来看第1行，这一行表示PID为984的程序正在135端口等待另一方的连接，其中本地IP地址和远程IP地址都是0.0.0.0，这表示通信还没开始，IP地址不确定

> 备注：
> PID: Process ID (进程表示符)的缩写，是操作系统为了标识程序而分配的编号，使用任务管理器可以查询所对应的应用程序名称。

![image-20220311144258864](http://static.wollens.top/image-20220311144258864.png)

#### 调用 socket 时的操作

​	看过套接字的具体样子之后，接下来我们看看当浏览器调用 socket、connect 等 Socket 库中的程序组件时，协议栈内部是如何工作的。

​	首先，我们再来看一下浏览器通过 Socket 库向协议栈发出委托的一系列操作（图2.3）。正如我们之前讲过的那样，浏览器委托协议栈使用 TCP 协议来收发数据，因此下面的讲解都是关于 TCP 的。

​	首先调用 gethostbyname 获取域名对应的 IP 地址， 然后创建套接字阶段，如图2.3①所示，应用程序调用socket申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。

​	在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间，这相当于为控制信息准备一个容器。但光一个容器并没有什么用，还需要往里面存入控制信息。套接字刚刚创建时，数据收发操作还没有开始，因此需要再套接字的内存空间中写入表示这一初始状态的控制信息。到这里，创建套接字的操作就完成了。

![image-20220311145958456](http://static.wollens.top/image-20220311145958456.png)

​	接下来，需要将表示这个套接字的描叙符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌。收到描述符后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信。